<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Three.js JSON Loader</title>
  <style>
    body { margin: 0; overflow: hidden; background: #222; color: #ddd; font-family: sans-serif; }
    #fileInput {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: #444;
      padding: 6px 12px;
      border-radius: 4px;
      color: white;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <input type="file" id="fileInput" accept=".json" />
  <script type="module">
    import * as THREE from 'https://esm.sh/three@0.160.0';
    import { TransformControls } from 'https://esm.sh/three@0.160.0/examples/jsm/controls/TransformControls.js';
    import { OrbitControls } from 'https://esm.sh/three@0.160.0/examples/jsm/controls/OrbitControls.js';

    let scene, camera, renderer, orbitControls;
    let objects = [];

    init();
    animate();

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x222222);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 5, 10);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      orbitControls = new OrbitControls(camera, renderer.domElement);
      orbitControls.target.set(0, 1, 0);
      orbitControls.update();

      // Lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(5, 10, 7);
      scene.add(directionalLight);

      // Grid helper
      const grid = new THREE.GridHelper(20, 20);
      scene.add(grid);

      // Handle file input
      const fileInput = document.getElementById('fileInput');
      fileInput.addEventListener('change', handleFile, false);

      window.addEventListener('resize', onWindowResize, false);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function handleFile(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = e => {
        try {
          const json = JSON.parse(e.target.result);
          loadObjectsFromJSON(json);
        } catch (err) {
          alert('Error parsing JSON: ' + err.message);
        }
      };
      reader.readAsText(file);
    }

    function loadObjectsFromJSON(json) {
      // Clear previous objects
      for (const obj of objects) {
        scene.remove(obj);
      }
      objects = [];

      json.forEach(objData => {
        let mesh;
        const pos = objData.position;
        const rot = objData.rotation; // e.g. [x, y, z, "XYZ"]
        const scl = objData.scale;

        if (objData.name === 'Cube') {
          const geometry = new THREE.BoxGeometry(1,1,1);
          const material = new THREE.MeshStandardMaterial({ color: 0x00aaff });
          mesh = new THREE.Mesh(geometry, material);
        } else if (objData.name === 'PlayerSpawn') {
          const geometry = new THREE.SphereGeometry(0.5, 16, 16);
          const material = new THREE.MeshStandardMaterial({ color: 0xffaa00 });
          mesh = new THREE.Mesh(geometry, material);
        } else {
          // Default placeholder box for unknown objects
          const geometry = new THREE.BoxGeometry(1,1,1);
          const material = new THREE.MeshStandardMaterial({ color: 0x888888, wireframe: true });
          mesh = new THREE.Mesh(geometry, material);
        }

        mesh.position.set(pos[0], pos[1], pos[2]);

        // Rotation: assuming Euler angles in radians, order given as string (default "XYZ")
        if (rot && rot.length === 4) {
          const order = rot[3];
          mesh.rotation.order = order || 'XYZ';
          mesh.rotation.set(rot[0], rot[1], rot[2]);
        }

        mesh.scale.set(scl[0], scl[1], scl[2]);

        scene.add(mesh);
        objects.push(mesh);
      });
    }

    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
